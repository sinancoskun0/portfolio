<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Text Helix Visualizer</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #0b0b12;
    font-family: Arial, sans-serif;
    color: white;
  }

  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    background: rgba(0,0,0,0.6);
    padding: 10px 14px;
    border-radius: 8px;
  }

  input {
    width: 300px;
    padding: 6px;
    border-radius: 4px;
    border: none;
    font-size: 14px;
  }
</style>
</head>
<body>

<div id="ui">
  <input id="textInput" value="HELIX VISUALIZER" />
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>

<script>
let scene, camera, renderer, controls;
let helixGroup = new THREE.Group();
let font;
const radius = 6;
const pitch = 0.5;
const spacing = 0.4;

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 8, 20);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  scene.add(light);

  scene.add(helixGroup);

  new THREE.FontLoader().load(
    "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
    f => {
      font = f;
      buildHelix(document.getElementById("textInput").value);
    }
  );

  document.getElementById("textInput").addEventListener("input", e => {
    buildHelix(e.target.value);
  });

  window.addEventListener("resize", onResize);
}

function buildHelix(text) {
  helixGroup.clear();
  if (!font || !text) return;

  const chars = text.split("");
  const material1 = new THREE.MeshStandardMaterial({ color: 0x00ffff });
  const material2 = new THREE.MeshStandardMaterial({ color: 0xff00ff });

  chars.forEach((char, i) => {
    const angle = i * spacing * Math.PI * 2;
    const y = i * pitch - chars.length * pitch / 2;

    createChar(char, angle, y, radius, material1);
    createChar(char, angle + Math.PI, y, radius, material2);
  });
}

function createChar(char, angle, y, r, material) {
  const geo = new THREE.TextGeometry(char, {
    font,
    size: 0.6,
    height: 0.15,
    curveSegments: 6
  });

  geo.computeBoundingBox();
  geo.center();

  const mesh = new THREE.Mesh(geo, material);
  mesh.position.set(
    Math.cos(angle) * r,
    y,
    Math.sin(angle) * r
  );
  mesh.lookAt(0, y, 0);

  helixGroup.add(mesh);
}

function animate() {
  requestAnimationFrame(animate);
  helixGroup.rotation.y += 0.003;
  controls.update();
  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
