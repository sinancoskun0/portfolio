<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Text Double Helix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            color: white;
        }
        input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            color: cyan;
            padding: 8px;
            width: 200px;
            outline: none;
        }
        p { font-size: 12px; color: #aaa; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="ui">
        <input type="text" id="textInput" placeholder="Type something..." value="DOUBLE HELIX">
        <p>Left Click: Rotate | Scroll: Zoom</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        const group = new THREE.Group();
        scene.add(group);

        // Lighting
        const light = new THREE.PointLight(0x00ffff, 100, 100);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // --- Helix Logic ---
        let font;
        const loader = new FontLoader();
        const helixMeshes = [];
        
        // Load font and start
        loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (f) => {
            font = f;
            createTextHelix(document.getElementById('textInput').value);
        });

        function createTextHelix(text) {
            // Clear existing
            helixMeshes.forEach(m => group.remove(m));
            helixMeshes.length = 0;

            const chars = text.split("");
            const segments = 40; // Total characters displayed
            const radius = 4;
            const heightStep = 0.4;
            const twist = 0.5;

            for (let i = 0; i < segments; i++) {
                const char = chars[i % chars.length];
                const geometry = new TextGeometry(char, {
                    font: font,
                    size: 0.5,
                    height: 0.1,
                });
                geometry.center();

                // Two strands (0 and PI offset)
                [0, Math.PI].forEach((offset, strandIndex) => {
                    const material = new THREE.MeshPhongMaterial({ 
                        color: strandIndex === 0 ? 0x00ffff : 0xff00ff,
                        emissive: strandIndex === 0 ? 0x001111 : 0x110011
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    const angle = i * twist + offset;
                    const y = (i - segments / 2) * heightStep;
                    
                    mesh.position.set(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    );
                    
                    // Look at center axis
                    mesh.lookAt(0, y, 0);
                    
                    group.add(mesh);
                    helixMeshes.push(mesh);
                });
            }
        }

        // --- Interaction ---
        document.getElementById('textInput').addEventListener('input', (e) => {
            if (font) createTextHelix(e.target.value || " ");
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.01; // Constant rotation
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>